// xdv-core: targeted runtime and filesystem repair workflows

forge XdvCoreRepairApp {

    const APP_ID: UInt32 = 32;

    const STATUS_OK: UInt32 = 0;
    const STATUS_REPAIR_FAILED: UInt32 = 1;

    proc K::repair_status() {
        let diag = recovery_diagnostics();
        if diag == STATUS_OK {
            return STATUS_OK;
        } else {
            return STATUS_REPAIR_FAILED;
        }
    }

    proc K::repair_storage(device: Str, mount_point: Str) {
        let repaired = recovery_repair(device, mount_point);
        if repaired == STATUS_OK {
            return STATUS_OK;
        } else {
            return STATUS_REPAIR_FAILED;
        }
    }

    proc K::repair_runtime_reload() {
        let reloaded = recovery_reload_runtime();
        if reloaded == STATUS_OK {
            let runtime = run_runtime_minimum_set();
            if runtime == STATUS_OK {
                return STATUS_OK;
            } else {
                return STATUS_REPAIR_FAILED;
            }
        } else {
            return STATUS_REPAIR_FAILED;
        }
    }

    proc K::repair_permissions(path: Str) {
        let restored = security_restore(path);
        if restored == STATUS_OK {
            return STATUS_OK;
        } else {
            return STATUS_REPAIR_FAILED;
        }
    }

    proc K::repair_safe_mode(device: Str, mount_point: Str) {
        let safe = recovery_safe_mode(device, mount_point);
        if safe == STATUS_OK {
            return STATUS_OK;
        } else {
            return STATUS_REPAIR_FAILED;
        }
    }

    proc K::repair_full(device: Str, mount_point: Str, path: Str) {
        let fs = repair_storage(device, mount_point);
        if fs == STATUS_OK {
            let perms = repair_permissions(path);
            if perms == STATUS_OK {
                return repair_runtime_reload();
            } else {
                return STATUS_REPAIR_FAILED;
            }
        } else {
            return STATUS_REPAIR_FAILED;
        }
    }
}
